## Java对象的生命周期
### 在Java中，对象的生命周期包括以下几个阶段
1. 创建阶段（Created）  
    在创建阶段系统通过以下几个步骤来完成对象的创建
    * 为对象分配存储空间
    * 开始构造对象
    * 从父类到子类对static成员进行初始化
    * 父类成员按顺序初始化，递归调用父类的构造方法
    * 子类成员变量按顺序初始化，调用子类的构造方法     

    ```
    public Dog getDog() {
        Dog dog = new Dog();
        return dog;
    }
    ``` 

    一旦对象被创建，并分派给某些变量赋值，这个对象的状态就切换到了应用状态

2. 应用阶段（In Use）     
对象至少被一个强引用持有称为处于应用阶段，一个对象可以有多个强引用，GC不会回收处于应用状态的对象        
    ```
    Dog dog = new Dog(); 
    ```
3. 不可见阶段       
强引用对象超出其作用域之后就变为不可见，当一个对象处于不可见阶段是，说明程序本身不再持有该对象的不论说明强引用，尽管这些引用仍然是存在的。
4. 不可达阶段   
在虚拟机所管理的对象引用根集合再也找不到直接或间接的强引用，这些对象通常是指所有线程栈中的临时变量，所有已装载的类的静态变量或者本地代码接口的引用。这些对象都是要被垃圾回收回收的预备对象，但此时该对象并不能被垃圾回收器直接回收。其实所有垃圾回收算法所面临的问题是相同的——找出由分配器分配的，但是用户程序不可到达的内存块。
5. 收集阶段（Collected）    
当垃圾回收器发现该对象已经处于“不可达阶段”而且垃圾回收器已经对该对象内存空间的又一次分配做好了准备是，则对象进入了“收集阶段”。假设该对象已经重写了finalize方法，则回去运行该方法的终端操作。    
注意：不要重载finazlie()方法！  
原因有两点：
    * 会影响JVM的对象分配与回收速度     
    在分配该对象时，JVM要在垃圾回收器上注册该对象，以便在回收时可以运行该重载方法；在该方法的运行时要消耗CPU时间且在运行完该方法后才会又一次运行回收操作，即至少需要垃圾回收器对该对象运行两次GC
    * 可能造成该对象的再次“复活”    
    在finzlize()方法中，假设有其它的强引用再次持有该对象，则会导致对象的状态由“收集阶段”又一次变为“应用阶段”。这个已经破坏了Java对象的生命周期进程，且“复活”的对象不利于代码管理。
6. 终结阶段     
当对象运行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。
7. 对象空间的又一次分配阶段     
垃圾回收器对该对象的所占内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间的又一次分配阶段”。